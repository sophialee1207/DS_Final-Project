"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluentServer = void 0;
const net = require("net");
const tls = require("tls");
const crypto = require("crypto");
const events_1 = require("events");
const protocol = require("./protocol");
const error_1 = require("./error");
/**
 * Manages the state of the client
 */
var ClientState;
(function (ClientState) {
    /**
     * Can receive events from this client
     */
    ClientState[ClientState["ESTABLISHED"] = 0] = "ESTABLISHED";
    /**
     * Waiting for a PING from this client
     */
    ClientState[ClientState["PING"] = 1] = "PING";
})(ClientState || (ClientState = {}));
/**
 * A Fluent [Forward protocol](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1) compatible server
 */
class FluentServer extends events_1.EventEmitter {
    /**
     * Creates a new server
     *
     * @param options The server connection options
     */
    constructor(options = {}) {
        super();
        this.clients = {};
        this.listenOptions = options.listenOptions || { port: 0 };
        this.tlsOptions = options.tlsOptions || null;
        this.security = options.security || null;
        this.clients = {};
        this.keepalive = options.keepalive || true;
        if (this.tlsOptions) {
            this.server = tls.createServer(this.tlsOptions, socket => this.handleConnection(socket));
        }
        else {
            this.server = net.createServer(socket => this.handleConnection(socket));
        }
    }
    /**
     * Handles a connection event on the server
     * @param socket
     */
    async handleConnection(socket) {
        var _a;
        const clientKey = socket.remoteAddress + ":" + socket.remotePort;
        socket.on("end", () => {
            if (this.clients.hasOwnProperty(clientKey)) {
                delete this.clients[clientKey];
            }
        });
        const clientInfo = {
            socket,
            state: ClientState.ESTABLISHED,
        };
        this.clients[clientKey] = clientInfo;
        if (this.security) {
            clientInfo.serverKeyInfo = {
                nonce: crypto.randomBytes(16),
                key: this.security.sharedKey,
            };
            if ((_a = this.security) === null || _a === void 0 ? void 0 : _a.authorize) {
                clientInfo.authSalt = crypto.randomBytes(16);
            }
            const helo = protocol.encodeMessage(protocol.generateHelo(clientInfo.serverKeyInfo.nonce, clientInfo.authSalt || "", this.keepalive));
            socket.write(helo);
            clientInfo.state = ClientState.PING;
        }
        // This will auto close the socket on close/decode error. We don't generally care, so this is fine
        try {
            for await (const message of protocol.decodeClientStream(socket)) {
                if (clientInfo.state === ClientState.PING && protocol.isPing(message)) {
                    if (!clientInfo.serverKeyInfo || !this.security) {
                        // Unexpected PONG when we didn't send a HELO
                        throw new error_1.UnexpectedMessageError("Unexpected PING");
                    }
                    try {
                        const authResult = protocol.checkPing(message, this.security.serverHostname, clientInfo.serverKeyInfo, clientInfo.authSalt
                            ? {
                                salt: clientInfo.authSalt,
                                userDict: this.security.userDict,
                            }
                            : undefined);
                        clientInfo.sharedKeyInfo = authResult.sharedKeyInfo;
                        const pong = protocol.generatePong(this.security.serverHostname, true, "", clientInfo.sharedKeyInfo);
                        socket.write(protocol.encodeMessage(pong));
                        clientInfo.state = ClientState.ESTABLISHED;
                    }
                    catch (e) {
                        const pong = protocol.generatePong(this.security.serverHostname, false, e.message, clientInfo.sharedKeyInfo);
                        socket.write(protocol.encodeMessage(pong));
                        throw e;
                    }
                }
                else if (clientInfo.state === ClientState.ESTABLISHED &&
                    protocol.isClientTransportMessage(message)) {
                    const decodedEntries = protocol.parseTransport(message);
                    if (decodedEntries.chunk) {
                        const ack = protocol.encodeMessage(protocol.generateAck(decodedEntries.chunk));
                        socket.write(ack);
                    }
                    decodedEntries.entries.forEach(entry => {
                        this.onEntry(decodedEntries.tag, ...entry);
                    });
                }
                else {
                    throw new error_1.UnexpectedMessageError("Unexpected message");
                }
            }
        }
        catch (e) {
            // Bad socket!
            socket.end();
        }
    }
    /**
     * Called for each entry received by the server.
     *
     * @param tag The tag of the entry
     * @param time The timestamp of the entry
     * @param record The entry record
     */
    onEntry(tag, time, record) {
        this.emit("entry", tag, time, record);
    }
    /**
     * Returns the port the server is currently listening on
     */
    get port() {
        return this._port;
    }
    /**
     * Start the server
     *
     * @returns A Promise which resolves once the server is listening
     */
    listen() {
        return new Promise(resolve => {
            this.server.listen(this.listenOptions, () => {
                const address = this.server.address();
                this._port =
                    address && typeof address === "object" ? address.port : undefined;
                resolve();
            });
        });
    }
    /**
     * Shutdown the server
     *
     * @returns A Promise, which resolves once the server has fully shut down.
     */
    close() {
        return new Promise(resolve => {
            this.server.close(() => {
                resolve();
            });
            Object.values(this.clients).forEach(clientInfo => clientInfo.socket.end());
        });
    }
}
exports.FluentServer = FluentServer;
//# sourceMappingURL=server.js.map