"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForwardQueue = void 0;
const queue_1 = require("./queue");
const protocol = require("../protocol");
const util_1 = require("../util");
/**
 * Implements the Forward specification's [Forward mode](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#forward-mode)
 */
class ForwardQueue extends queue_1.Queue {
    constructor() {
        super(...arguments);
        /**
         * Maintain the queue as a Map
         *
         * JS guarantees maps are insertion ordered, so calling sendQueue.values().next.value will be the first tag to be inserted.
         */
        this.sendQueue = new Map();
        /**
         * The total number of events stored within the queue
         *
         * Note that this isn't just sendQueue.size because each entry in the map can have multiple events
         */
        this.sendQueueLength = 0;
    }
    /**
     * Size is not measured for this queue
     */
    get queueSize() {
        return -1;
    }
    get queueLength() {
        return this.sendQueueLength;
    }
    push(tag, time, data) {
        const entry = protocol.generateEntry(time, data);
        this.sendQueueLength += 1;
        if (this.sendQueue.has(tag)) {
            const entryData = this.sendQueue.get(tag);
            entryData.entries.push(entry);
            return entryData.deferred.promise;
        }
        else {
            const deferred = util_1.pDefer();
            this.sendQueue.set(tag, {
                tag,
                entries: [entry],
                deferred: deferred,
            });
            return deferred.promise;
        }
    }
    pop() {
        if (this.sendQueue.size === 0) {
            return null;
        }
        const entryData = this.sendQueue.values().next().value;
        this.sendQueue.delete(entryData.tag);
        this.sendQueueLength -= entryData.entries.length;
        return entryData;
    }
    nextPacket(chunk) {
        const entryData = this.pop();
        if (entryData === null) {
            return null;
        }
        const packet = protocol.generateForwardMode(entryData.tag, entryData.entries, chunk);
        return {
            packet: protocol.encodeMessage(packet),
            deferred: entryData.deferred,
        };
    }
}
exports.ForwardQueue = ForwardQueue;
//# sourceMappingURL=forward.js.map