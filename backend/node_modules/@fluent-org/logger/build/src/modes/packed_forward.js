"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressedPackedForwardQueue = exports.PackedForwardQueue = void 0;
const queue_1 = require("./queue");
const protocol = require("../protocol");
const util_1 = require("../util");
/**
 * Implements the Forward specification's [(Compressed)?PackedForward mode](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#packedforward-mode)
 *
 * Implements both in the same queue, because the only code difference is compression in `nextPacket`.
 *
 * Subclassed below into the correct modes.
 */
class BasePackedForwardQueue extends queue_1.Queue {
    constructor() {
        super(...arguments);
        /**
         * Maintain the queue as a Map
         *
         * JS guarantees maps are insertion ordered, so calling sendQueue.values().next.value will be the first tag to be inserted.
         */
        this.sendQueue = new Map();
        /**
         * The total size of the buffers in the queue
         */
        this.sendQueueSize = 0;
        /**
         * The total number of events stored within the queue
         *
         * Note that this isn't just sendQueue.size because each entry in the map can have multiple events
         */
        this.sendQueueLength = 0;
        /**
         * Used to gate compression of `nextPacket`. The difference between PackedForward and CompressedPackedForward
         */
        this.compressed = false;
    }
    get queueSize() {
        return this.sendQueueSize;
    }
    get queueLength() {
        return this.sendQueueLength;
    }
    push(tag, time, data) {
        const entry = protocol.packEntry(protocol.generateEntry(time, data));
        this.sendQueueSize += entry.length;
        this.sendQueueLength += 1;
        if (this.sendQueue.has(tag)) {
            const entryData = this.sendQueue.get(tag);
            entryData.entries.push(entry);
            entryData.size += entry.length;
            return entryData.deferred.promise;
        }
        else {
            const deferred = util_1.pDefer();
            this.sendQueue.set(tag, {
                tag,
                entries: [entry],
                size: entry.length,
                deferred: deferred,
            });
            return deferred.promise;
        }
    }
    pop() {
        if (this.sendQueue.size === 0) {
            return null;
        }
        const entryData = this.sendQueue.values().next().value;
        this.sendQueue.delete(entryData.tag);
        this.sendQueueLength -= entryData.entries.length;
        this.sendQueueSize -= entryData.size;
        return entryData;
    }
    nextPacket(chunk) {
        const entryData = this.pop();
        if (entryData === null) {
            return null;
        }
        let packet;
        if (this.compressed) {
            packet = protocol.generateCompressedPackedForwardMode(entryData.tag, entryData.entries, entryData.size, chunk);
        }
        else {
            packet = protocol.generatePackedForwardMode(entryData.tag, entryData.entries, entryData.size, chunk);
        }
        return {
            packet: protocol.encodeMessage(packet),
            deferred: entryData.deferred,
        };
    }
}
/**
 * Implements the Forward specification's [PackedForward mode](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#packedforward-mode)
 */
class PackedForwardQueue extends BasePackedForwardQueue {
    constructor() {
        super(...arguments);
        this.compressed = false;
    }
}
exports.PackedForwardQueue = PackedForwardQueue;
/**
 * Implements the Forward specification's [CompressedPackedForward mode](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#compressedpackedforward-mode)
 */
class CompressedPackedForwardQueue extends BasePackedForwardQueue {
    constructor() {
        super(...arguments);
        this.compressed = true;
    }
}
exports.CompressedPackedForwardQueue = CompressedPackedForwardQueue;
//# sourceMappingURL=packed_forward.js.map