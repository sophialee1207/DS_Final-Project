"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluentAuthSocket = void 0;
const crypto = require("crypto");
const socket_1 = require("./socket");
const error_1 = require("./error");
const protocol = require("./protocol");
var FluentAuthState;
(function (FluentAuthState) {
    /**
     * The client is not authenticated (socket is not connected)
     */
    FluentAuthState[FluentAuthState["UNAUTHENTICATED"] = 0] = "UNAUTHENTICATED";
    /**
     * The client is waiting for a HELO from the server
     */
    FluentAuthState[FluentAuthState["HELO"] = 1] = "HELO";
    /**
     * The client is waiting for a PONG from the server
     */
    FluentAuthState[FluentAuthState["PONG"] = 2] = "PONG";
    /**
     * The client is fully authenticated
     */
    FluentAuthState[FluentAuthState["AUTHENTICATED"] = 3] = "AUTHENTICATED";
})(FluentAuthState || (FluentAuthState = {}));
/**
 * An implementation of FluentSocket which authenticates the socket using the [Forward protocol Handshake](https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#handshake-messages)
 */
class FluentAuthSocket extends socket_1.FluentSocket {
    /**
     * Creates a new instance of the socket
     * @param authOptions The authentication options to use
     * @param socketOptions The socket options to pass to the underlying socket
     */
    constructor(authOptions, socketOptions = {}) {
        super(socketOptions);
        this.authState = FluentAuthState.UNAUTHENTICATED;
        this.clientHostname = authOptions.clientHostname;
        this.sharedKeyInfo = {
            salt: crypto.randomBytes(16).toString("hex"),
            nonce: "",
            key: authOptions.sharedKey,
        };
        this.username = authOptions.username || "";
        this.password = authOptions.password || "";
    }
    /**
     * Once the socket is connected, we expect a HELO
     */
    onConnected() {
        this.authState = FluentAuthState.HELO;
    }
    /**
     * When the socket is closed, we're unauthenticated
     */
    onClose() {
        this.authState = FluentAuthState.UNAUTHENTICATED;
        super.onClose();
    }
    /**
     * Handles messages from the server
     *
     * If we're waiting for a message, this will trigger it, otherwise just forward to the superclass.
     *
     * @param message The message to check
     */
    onMessage(message) {
        if (protocol.isHelo(message) && this.authState === FluentAuthState.HELO) {
            this.handleHelo(message);
        }
        else if (protocol.isPong(message) &&
            this.authState === FluentAuthState.PONG) {
            this.handlePong(message);
        }
        else if (this.authState === FluentAuthState.AUTHENTICATED) {
            super.onMessage(message);
        }
        else {
            this.close(socket_1.CloseState.FATAL, new error_1.UnexpectedMessageError("Received unexpected message"));
        }
    }
    /**
     * Called on a HELO message
     *
     * Should parse the message, and send back a PING
     *
     * @param message The HELO message
     */
    handleHelo(message) {
        const heloOptions = protocol.parseHelo(message);
        this.authState = FluentAuthState.PONG;
        this.sharedKeyInfo.nonce = heloOptions.nonce;
        if (heloOptions.auth) {
            this.authInfo = {
                username: this.username,
                password: this.password,
                salt: heloOptions.auth,
            };
        }
        // Write to the socket directly (bypass writable() below)
        const ping = protocol.encodeMessage(protocol.generatePing(this.clientHostname, this.sharedKeyInfo, this.authInfo));
        this.socketWrite(ping).catch(err => this.close(socket_1.CloseState.RECONNECT, err));
    }
    /**
     * Called on a PONG message
     *
     * Should parse and validate the message, and if valid, establish the connection
     *
     * @param message The PONG message
     * @returns void
     */
    handlePong(message) {
        try {
            protocol.checkPong(message, this.clientHostname, this.sharedKeyInfo);
            this.authState = FluentAuthState.AUTHENTICATED;
            this.onEstablished();
        }
        catch (e) {
            return this.close(socket_1.CloseState.FATAL, e);
        }
    }
}
exports.FluentAuthSocket = FluentAuthSocket;
//# sourceMappingURL=auth.js.map