/// <reference types="node" />
import * as tls from "tls";
import { EventEmitter } from "events";
import * as protocol from "./protocol";
/**
 * Reconnection settings for the socket
 *
 * The parameters represent an exponential backoff formula:
 * min(maxDelay, max(minDelay, backoff^attempts * delay))
 *
 * The attempt count is incremented each time we fail a connection,
 * and set to zero each time a connection is successfully made.
 * Note this is before handshaking
 */
export declare type ReconnectOptions = {
    /**
     * The backoff factor for each attempt
     *
     * Defaults to 2
     */
    backoff: number;
    /**
     * The delay factor for each attempt
     *
     * Defaults to 500
     */
    delay: number;
    /**
     * The global minimum delay
     */
    minDelay: number;
    /**
     * The global maximum delay
     */
    maxDelay: number;
};
export declare type FluentSocketOptions = {
    /**
     * If connecting to a unix domain socket, e.g unix:///var/run/fluentd.sock, then specify that here.
     *
     * This overrides host/port below. Defaults to `undefined`.
     */
    path?: string;
    /**
     * The host (IP) to connect to
     *
     * Defaults to `localhost`.
     */
    host?: string;
    /**
     * The port to connect to
     *
     * Defaults to `24224`.
     */
    port?: number;
    /**
     * The socket timeout to set. After timing out, the socket will be idle and reconnect once the client wants to write something.
     *
     * Defaults to 3000 (3 seconds)
     *
     * Set to -1 for no timeout
     */
    timeout?: number;
    /**
     * TLS connection options. See [Node docs](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback)
     *
     * If provided, the socket will be a TLS socket.
     */
    tls?: tls.ConnectionOptions;
    /**
     * Reconnection options. See subtype for defaults.
     */
    reconnect?: Partial<ReconnectOptions>;
    /**
     * Disable reconnection on failure. This can be useful for one-offs, or if you'd like to manually manage the connection.
     *
     * Prevents the socket from being created on client create.
     *
     * Defaults to false
     */
    disableReconnect?: boolean;
    /**
     * Treat the socket as not writable when draining.
     *
     * This can reduce memory use, but only when the client slows down emission.
     * Otherwise either the send buffer fills up or the FluentClient.sendQueue fills up.
     *
     * Defaults to false
     */
    notWritableWhenDraining?: boolean;
};
export declare enum FluentSocketEvent {
    /**
     * Emitted once the socket has successfully been opened to the upstream server
     *
     * Provides no arguments
     */
    CONNECTED = "connected",
    /**
     * Emitted once the socket is ready to receive Messages
     *
     * Provides no arguments
     */
    ESTABLISHED = "established",
    /**
     * Emitted when the socket is starting to fill up the send buffer, and stops accepting writes.
     * See [net.Socket.write](https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback) for more info.
     *
     * Provides no arguments
     */
    DRAINING = "draining",
    /**
     * Emit once the socket has emptied the send buffer again.
     * See [net.Socket 'drain'](https://nodejs.org/api/net.html#net_event_drain) for more info.
     *
     * Provides no arguments
     */
    DRAINED = "drained",
    /**
     * Emitted when the socket has timed out. It will be reconnected once the socket gets an attempted write (or next writable call)
     *
     * Provides no arguments
     */
    TIMEOUT = "timeout",
    /**
     * Emitted when the socket receives an ACK message. Mostly for internal use.
     */
    ACK = "ack",
    /**
     * Emitted when the socket is writable. This is emitted at the same time as the ESTABLISHED and the DRAINED events.
     *
     * Provides no arguments
     */
    WRITABLE = "writable",
    /**
     * Emitted when the socket receives an error.
     *
     * Provides one argument - the Error object associated with it.
     */
    ERROR = "error",
    /**
     * Emitted when the socket is closed for any reason.
     */
    CLOSE = "close"
}
/**
 * How to close the socket
 */
export declare enum CloseState {
    /**
     * Make the socket unable to reconnect
     */
    FATAL = 0,
    /**
     * Allow the socket to reconnect automatically
     */
    RECONNECT = 1
}
/**
 * A wrapper around a Fluent Socket
 *
 * Handles connecting the socket, and manages error events and reconnection
 */
export declare class FluentSocket extends EventEmitter {
    private state;
    private socket;
    private reconnectTimeoutId;
    private connectAttempts;
    private socketParams;
    private timeout;
    private tlsEnabled;
    private tlsOptions;
    private reconnectEnabled;
    private writableWhenDraining;
    private reconnect;
    /**
     * Used so we can read from the socket through an AsyncIterable.
     * Protects the reader from accidentally closing the socket on errors.
     */
    private passThroughStream;
    /**
     * Creates a new socket
     *
     * @param options The socket connection options
     */
    constructor(options?: FluentSocketOptions);
    /**
     * Connects the socket to the upstream server
     *
     * Can throw a connection error, we may reconnect from this state, but the error will still be thrown
     *
     * @returns void
     */
    connect(): Promise<void>;
    /**
     * May reconnect the socket
     * @returns void
     */
    private maybeReconnect;
    /**
     * Creates a new TLS socket
     * @returns A new socket to use for the connection
     */
    private createTlsSocket;
    /**
     * Creates a new TCP socket
     * @returns A new socket to use for the connection
     */
    private createTcpSocket;
    /**
     * Returns a new socket
     *
     * @param onConnect Called once the socket is connected
     * @returns
     */
    private createSocket;
    /**
     * Sets up and connects the socket
     *
     * @returns A promise which resolves once the socket is connected, or once it is errored
     */
    private openSocket;
    /**
     * Called once the socket is connected
     */
    private handleConnect;
    /**
     * Processes messages from the socket
     *
     * @param iterable The socket read data stream
     * @returns Promise for when parsing completes
     */
    private processMessages;
    /**
     * Called from an error event on the socket
     */
    private handleError;
    /**
     * Called when the socket times out
     * Should suspend the socket (set it to IDLE)
     */
    private handleTimeout;
    /**
     * Called from a "close" event on the socket
     *
     * Should clean up the state, and potentially trigger a reconnect
     */
    private handleClose;
    /**
     * Called when the socket has fully drained, and the buffers are free again
     */
    private handleDrain;
    /**
     * Handles a connection event on the connection
     *
     * Called once a connection is established
     */
    protected onConnected(): void;
    /**
     * Called once a connection is ready to accept writes externally
     */
    protected onEstablished(): void;
    /**
     * Called once we think socket.writable() will return true
     * Note that this event doesn't guarantee that socket.writable() will return true,
     * for example, the server might disconnect in between emitting the event and attempting a write.
     */
    protected onWritable(): void;
    /**
     * Handles an error event on the connection
     *
     * @param error The error
     */
    protected onError(error: Error): void;
    /**
     * Handles a close event from the socket
     */
    protected onClose(): void;
    emit(event: string | symbol, ...args: any[]): boolean;
    /**
     * Handles a message from the server
     *
     * @param message The decoded message
     */
    protected onMessage(message: protocol.ServerMessage): void;
    /**
     * Handle an ack from the server
     *
     * @param chunkId The chunk from the ack event
     */
    protected onAck(chunkId: protocol.Chunk): void;
    /**
     * Gracefully closes the connection
     *
     * Changes state to DISCONNECTING, meaning we don't reconnect from this state
     */
    disconnect(): Promise<void>;
    /**
     * Forcefully closes the connection, and optionally emits an error
     *
     * Changes state to DISCONNECTING, meaning we don't reconnect from this state
     * @param closeState The state to close this socket in
     * @param error The error that closed the socket
     */
    close(closeState: CloseState, error?: Error): void;
    /**
     * Check if the socket is writable
     *
     * Will terminate the socket if it is half-closed
     *
     * Will connect the socket if it is disconnected
     * @returns If the socket is in a state to be written to
     */
    private socketWritable;
    /**
     * Check if the socket is writable for clients
     *
     * @returns If the socket is in a state to be written to
     */
    writable(): boolean;
    private innerWrite;
    /**
     * Write data to the socket
     *
     * Fails if the socket is not writable
     *
     * @param data The data to write to the socket
     * @returns A Promise, which resolves when the data is successfully written to the socket, or rejects if it couldn't be written
     */
    protected socketWrite(data: Uint8Array): Promise<void>;
    /**
     * Write data to the socket
     *
     * Fails if the socket is not writable
     *
     * @param data The data to write to the socket
     * @returns A Promise, which resolves when the data is successfully written to the socket, or rejects if it couldn't be written
     */
    write(data: Uint8Array): Promise<void>;
}
